using System.Buffers;
using System.Data;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System;
using SharpTrader.AlgoFramework;


namespace SharpTrader
{

    public struct TimeRecord
    {
        public long Time;
        public double value;
        public TimeRecord(long time, double value)
        {
            Time = time;
            this.value = value;
        }
    }
    /// <summary>
    /// Trading stats to be compared with those generated by ML training scripts
    /// </summary>
    public class TradingStats
    {
        private double diff_sqr_avg_root;
        private double squareGainOverStdDev;
        private bool Dirty = false;
        private long LastDayAdded = -1;
        private List<TimeRecord> EquityHistory { get; set; } = new List<TimeRecord>();
        private List<TimeRecord> EquityHistoryByDay { get; set; } = new List<TimeRecord>() { new TimeRecord(0, 0) };
        private long T0;

        public double MaxGain { get; private set; }
        public double MaxDrowDown { get; private set; }
        public double GainPerOperation { get; private set; }
        public double GainOverMaxDrowDown { get; private set; }

        public int Count { get; private set; }
        public double Gain { get; private set; }

        public void AddOperation(Operation row)
        {
            Count += 1;
            Gain += (double)(row.CalculateGainAsQuteAsset() / row.QuoteAmountInvested);
            var entryTime = row.Entries.First().Time.ToEpoch();

            if (T0 == 0)
            {
                T0 = row.Entries.First().Time.ToEpoch();
            }
            var time = entryTime - T0;
            var gainCurveEntry = new TimeRecord(time, Gain);
            EquityHistory.Add(gainCurveEntry);
            // check if a new day has started
            long dayNow = time / (60 * 60 * 24);
            while (dayNow > LastDayAdded)
            {
                LastDayAdded++;
                EquityHistoryByDay.Add(gainCurveEntry);
            }
            // update capital for current day
            EquityHistoryByDay[EquityHistoryByDay.Count - 1] = gainCurveEntry;


            if (Gain > MaxGain)
                MaxGain = Gain;

            var drowDown = MaxGain - Gain;

            MaxDrowDown = Math.Max(MaxDrowDown, drowDown);

            GainPerOperation = Gain / Count;
            if (MaxDrowDown == 0)
                GainOverMaxDrowDown = 1000;
            else
                GainOverMaxDrowDown = Gain / MaxDrowDown;

            Dirty = true;
        }

        public double CubicGainOverStdDev
        {
            get
            {
                CalcStdDev();
                squareGainOverStdDev = Math.Sign(Gain) * ((Gain * Gain * Gain) / (1 + diff_sqr_avg_root));
                return squareGainOverStdDev;
            }
        }

        private void CalcStdDev()
        {
            if (Dirty && EquityHistoryByDay.Count > 2)
            {
                var dEdt = EquityHistoryByDay.Last().value / EquityHistoryByDay.Count;
                var os = EquityHistoryByDay.First().value;
                var diff_sqr_sum = 0d;
                for (int i = 0; i < EquityHistoryByDay.Count; i++)
                {
                    var diffsq = Math.Pow((EquityHistoryByDay[i].value - (dEdt * i + os)) / dEdt, 2);
                    diff_sqr_sum += diffsq;
                }
                diff_sqr_avg_root = Math.Sqrt(diff_sqr_sum / EquityHistoryByDay.Count);
                Dirty = false;
            }
        }

        public double SquareGainOverStdDev
        {
            get
            {
                CalcStdDev();
                squareGainOverStdDev = Math.Sign(Gain) * (Gain * Gain / (1 + diff_sqr_avg_root));
                return squareGainOverStdDev;
            }
        }

        public override string ToString()
        {
            return $"{{ Count: {Count} - Gain/MDD: {GainOverMaxDrowDown:F4} - Gain: {Gain:F4} - Gain/Oper: {GainPerOperation:F4} - SgOstdv: {SquareGainOverStdDev:F2} }}";
        }
    }
}